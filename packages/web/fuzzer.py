#!/usr/bin/env python3
"""
LLM-Powered Intelligent Web Fuzzer

Uses LLM to generate context-aware payloads for:
- SQL injection
- XSS
- Command injection
- Path traversal
- Authentication bypass
- And more...

NO STATIC PAYLOAD LISTS - Everything generated by LLM based on context.
"""

from typing import Dict, List, Optional, Any
import json
import sys
from pathlib import Path

# Add paths for cross-package imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from core.logging import get_logger
from packages.llm_analysis.llm.client import LLMClient
from packages.web.client import WebClient

logger = get_logger()


class WebFuzzer:
    """LLM-powered intelligent fuzzer - no static payloads."""

    def __init__(self, client: WebClient, llm: LLMClient):
        self.client = client
        self.llm = llm

        # Vulnerability findings
        self.findings: List[Dict[str, Any]] = []

        logger.info("Intelligent web fuzzer initialized (LLM-powered)")

    def fuzz_parameter(self, url: str, param_name: str, param_type: str = "text",
                      vulnerability_types: Optional[List[str]] = None) -> List[Dict]:
        """
        Fuzz a specific parameter with LLM-generated payloads.

        Args:
            url: Target URL
            param_name: Parameter name
            param_type: Parameter type (text, number, email, etc.)
            vulnerability_types: Types to test (sqli, xss, etc.)

        Returns:
            List of findings
        """
        if vulnerability_types is None:
            vulnerability_types = ['sqli', 'xss', 'command_injection', 'path_traversal']

        logger.info(f"Fuzzing parameter '{param_name}' at {url}")

        findings = []

        for vuln_type in vulnerability_types:
            # Generate intelligent payloads using LLM
            payloads = self._generate_payloads(param_name, param_type, vuln_type)

            for payload in payloads:
                finding = self._test_payload(url, param_name, payload, vuln_type)
                if finding:
                    findings.append(finding)
                    self.findings.append(finding)

        return findings

    def _generate_payloads(self, param_name: str, param_type: str,
                          vuln_type: str, count: int = 10) -> List[str]:
        """Generate intelligent payloads using LLM."""
        prompt = f"""You are a senior penetration tester generating test payloads for security testing.

**Target Parameter:**
- Name: {param_name}
- Type: {param_type}
- Vulnerability Type to Test: {vuln_type}

**Your Task:**
Generate {count} intelligent, context-aware payloads to test for {vuln_type} vulnerabilities.

**Requirements:**
1. Payloads should be realistic and likely to trigger the vulnerability
2. Include both basic and advanced evasion techniques
3. Tailor payloads to the parameter name and type
4. Include boundary cases and edge cases
5. Add polyglot payloads when relevant

**Examples of what to consider:**
- For 'email' parameters: email-specific injection vectors
- For 'id' or 'user_id': numeric SQL injection, IDOR tests
- For 'search' or 'query': Full-text search injection
- For 'file' or 'path': Path traversal, file inclusion

Respond with a JSON array of payload strings."""

        schema = {
            "payloads": ["list of payload strings"]
        }

        try:
            result = self.llm.generate_structured(
                prompt=prompt,
                schema=schema,
                task_type="exploit_generation",
            )

            payloads = result.get('payloads', [])
            logger.info(f"Generated {len(payloads)} payloads for {vuln_type}")
            return payloads

        except Exception as e:
            logger.error(f"Failed to generate payloads: {e}")
            # Fallback to basic payloads
            return self._get_basic_payloads(vuln_type)

    def _get_basic_payloads(self, vuln_type: str) -> List[str]:
        """Fallback basic payloads when LLM fails."""
        basic_payloads = {
            'sqli': ["' OR '1'='1", "' OR 1=1--", "'; DROP TABLE users--"],
            'xss': ["<script>alert('XSS')</script>", "<img src=x onerror=alert(1)>"],
            'command_injection': ["; ls", "| whoami", "`cat /etc/passwd`"],
            'path_traversal': ["../../../etc/passwd", "..\\..\\..\\windows\\win.ini"],
        }
        return basic_payloads.get(vuln_type, ["test"])

    def _test_payload(self, url: str, param_name: str, payload: str,
                     vuln_type: str) -> Optional[Dict]:
        """Test a payload against endpoint."""
        try:
            # Send request with payload
            response = self.client.get(url, params={param_name: payload})

            # Analyze response using LLM
            is_vulnerable = self._analyze_response(response, payload, vuln_type)

            if is_vulnerable:
                logger.warning(f"Potential {vuln_type} found in {param_name}")
                return {
                    'url': url,
                    'parameter': param_name,
                    'payload': payload,
                    'vulnerability_type': vuln_type,
                    'status_code': response.status_code,
                    'response_length': len(response.content),
                }

        except Exception as e:
            logger.debug(f"Error testing payload: {e}")

        return None

    def _analyze_response(self, response, payload: str, vuln_type: str) -> bool:
        """Use LLM to analyze if response indicates vulnerability."""
        # For now, simple heuristics (can be enhanced with LLM)
        if vuln_type == 'sqli':
            errors = ['sql', 'mysql', 'postgres', 'syntax error', 'database']
            return any(err in response.text.lower() for err in errors)

        elif vuln_type == 'xss':
            return payload in response.text

        elif vuln_type == 'command_injection':
            indicators = ['root:', 'bin/bash', 'uid=', 'gid=']
            return any(ind in response.text for ind in indicators)

        elif vuln_type == 'path_traversal':
            indicators = ['root:x:', '[boot loader]', 'windows']
            return any(ind in response.text.lower() for ind in indicators)

        return False

    def get_findings(self) -> List[Dict]:
        """Get all findings."""
        return self.findings
